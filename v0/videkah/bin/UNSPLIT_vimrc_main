"set smartindent


set tabstop=4
set shiftwidth=4
set expandtab

"====[ Set up smarter search behaviour ]=======================

"set background=dark
colors default

set incsearch       "Lookahead as search pattern is specified
set ignorecase      "Ignore case in all searches...
set smartcase       "...unless uppercase letters used
set hlsearch        "Highlight all matches

" cursor stuff . 
highlight iCursor guifg=cyan guibg=steelblue
highlight Cursor guifg=white guibg=steelblue

highlight EOLWS ctermbg=red guibg=red

"=====[ trailing space highlight ]==========================
"autocmd InsertEnter * syn clear EOLWS | syn match EOLWS excludenl /\s\+\%#\@!$/
"autocmd InsertLeave * syn clear EOLWS | syn match EOLWS excludenl /\s\+$/
"autocmd BufReadPost * syn clear EOLWS | syn match EOLWS excludenl /\s\+$/

"autocmd InsertEnter * syn clear EOLWS | syn match EOLWS /\s\+\%#\@!$/
"autocmd InsertLeave * syn clear EOLWS | syn match EOLWS /\s\+$/
"autocmd BufReadPost * syn clear EOLWS | syn match EOLWS /\s\+$/

augroup formatingExcessSpace
    autocmd!
    autocmd InsertEnter * syn clear EOLWS | match EOLWS /\s\+\%#\@!$/
    autocmd InsertLeave * syn clear EOLWS | match EOLWS /\s\+$/
    autocmd BufReadPost * syn clear EOLWS | match EOLWS /\s\+$/
augroup END

"set list
"set listchars=trail:â‚¬


set backspace=indent,eol,start      "BS past autoindents, line boundaries,
                                    "     and even the start of insertion

"=====[ Miscellaneous features (mainly options) ]=====================

set title           "Show filename in titlebar of window
set titleold=

set nomore          "Don't page long listings

set autoread        "Always reload buffer when external changes detected

"           +--Disable hlsearch while loading viminfo
"           | +--Remember marks for last 50 files
"           | |   +--Remember up to 10000 lines in each register
"           | |   |      +--Remember up to 1MB in each register
"           | |   |      |     +--Remember last 1000 search patterns
"           | |   |      |     |     +---Remember last 1000 commands
"           | |   |      |     |     |
"           v v   v      v     v     v
set viminfo=h,'50,<10000,s1000,/1000,:1000

set backspace=indent,eol,start      "BS past autoindents, line boundaries,
                                    "     and even the start of insertion

set fileformats=unix,mac,dos        "Handle Mac and DOS line-endings
                                    "but prefer Unix endings


set wildmode=list:longest,full      "Show list of completions
                                    "  and complete as much as possible,
                                    "  then iterate full completions

set noshowmode                      "Suppress mode change messages

set updatecount=10                  "Save buffer every 10 chars typed

set textwidth=3000                    "Wrap at column 78

" Keycodes and maps timeout in 3/10 sec...
set timeout timeoutlen=300 ttimeoutlen=300

set thesaurus+=~/Documents/thesaurus    "Add thesaurus file for ^X^T
set dictionary+=~/Documents/dictionary  "Add dictionary file for ^X^K


set scrolloff=4                     "Scroll when 2 lines from top/bottom

set ruler                           "Show cursor location info on status line

" Use space to jump down a page (like browsers do)...
"" nnoremap <Space> <PageDown>






"=====[ Enable smartwrapping ]==================================

" No smartwrapping in any of these files...
"let g:SW_IGNORE_FILES = '.vimrc,*.vim,*.pl,*.pm,**/bin/**'

" set comments-=s1:/*,mb:*,ex:*/      "Don't recognize C comments
" set comments-=:XCOMM                "Don't recognize lmake comments
" set comments-=:%                    "Don't recognize PostScript comments
" set comments-=:#                    "Don't recognize Perl/shell comments
" set comments+=fb:*                  "Star-space is a bullet
" set comments+=fb:-                  "Dash-space is a bullets

set formatoptions-=cro

set wrapmargin=2                            "Wrap 2 characters from the edge of the window


" need a quick way of switching on and off autoindent and smartindent 

"map . :set autoindent<cr>:set smartindent<cr>
"map , :set noautoindent<cr>:set nosmartindent<cr>

"set autoindent                              "Retain indentation on next line
"set smartindent                             "Turn on autoindenting of blocks


"set cinwords = ""                           "But not for C-like keywords
inoremap # X<C-H>#|                         "And no magic outdent for comments


"" nnoremap <silent> >> :call ShiftLine()<CR>| "And no shift magic on comments

"ctrl-s to save :-D
" DOESN'T WORK, need to switch off ctrl-s in TTY ... hmmm...
"map   <C-s>  :w   



set tabpagemax=15
" C-tab is the same as frickin tab . so the following doesn't work :-
"map   <C-tab>  :b#<cr>:echo @%<cr>


" move with ctrl up or down
map   <C-up> <C-y>
map   <C-down> <C-e>


"complete and utter rubbish that should get an error
" the flicking between tabs is controlled well by the TAB key !!!!!
"map   <F4>  :tabprevious<cr>:echo @%<cr>
"map   <F3>  :tabnext<cr>:echo @%<cr>


let &titlestring = $TITLE
if &term == "screen"
  set t_ts=^[k
  set t_fs=^[\
endif
if &term == "screen" || &term == "xterm"
  set title
endif

"====[ Use persistent undo ]=================
if has('persistent_undo')
    set undodir=$HOME/tmp/.VIM_UNDO_FILES
    set undolevels=5000
    set undofile
endif

"TODO: remap u to prompt when first undoing into a previous session's history
" (probably by calling undotree when the buffer is loaded,
"  remembering the current sequence number, and comparing it on each undo


"====[ Goto last location in non-empty files ]=======


"====[ I'm sick of typing :%s/.../.../g ]=======

nmap S  [Shortcut for :s///g]  :%s//g<LEFT><LEFT>
vmap S                         :s//g<LEFT><LEFT>


"====[ Toggle visibility of naughty characters ]============

" Make naughty characters visible...
" (uBB is right double angle, uB7 is middle dot)
" KARL : i find this painful on copy n paste operations. 
"exec \"set lcs=tab:\uBB\uBB,trail:\uB7,nbsp:~\"            <remove the \ from slash-double-quotes

"augroup VisibleNaughtiness
"    autocmd!
"    autocmd BufEnter  *       set list
"    autocmd BufEnter  *.txt   set nolist
"    autocmd BufEnter  *.vp*   set nolist
"    autocmd BufEnter  *       if !&modifiable
"    autocmd BufEnter  *           set nolist
"    autocmd BufEnter  *       endif
"augroup END



"=====[ Make Visual modes work better ]==================

" Visual Block mode is far more useful that Visual mode (so swap the commands)...
" err , I don't think so !! (KARL)

"nnoremap v <C-V>
"nnoremap <C-V> v

"vnoremap v <C-V>
"vnoremap <C-V> v



"Square up visual selections...
set virtualedit=block

" Make BS/DEL work as expected in visual modes (i.e. delete the selected text)...
vmap <BS> x

" Make vaa select the entire file...
vmap aa VGo1G

" When shifting, retain selection over multiple shifts...
vmap <expr> > KeepVisualSelection(">")
vmap <expr> < KeepVisualSelection("<")

function! KeepVisualSelection(cmd)
    if mode() ==# "V"
        return a:cmd . "gv"
    else
        return a:cmd
    endif
endfunction

" Temporarily add a column indicator when inserting or appending in visual mode...
" (Should use <C-O> instead, but it doesn't seem to work)
vnoremap <silent>  I  I<C-R>=TemporaryColumnMarkerOn()<CR>
vnoremap <silent>  A  A<C-R>=TemporaryColumnMarkerOn()<CR>

function! TemporaryColumnMarkerOn ()
    let g:prev_cursorcolumn_state = g:cursorcolumn_visible ? 'on' : 'off'
    call Toggle_CursorColumn('on')
    inoremap <silent>  <ESC>  <ESC>:call TemporaryColumnMarkerOff(g:prev_cursorcolumn_state)<CR>
    return ""
endfunction

function! TemporaryColumnMarkerOff (newstate)
    call Toggle_CursorColumn(a:newstate)
    iunmap <ESC>
endfunction

"==== configure the cursor

highlight Cursor guifg=white guibg=black
highlight iCursor guifg=white guibg=steelblue
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver100-iCursor
set guicursor+=n-v-c:blinkon0
set guicursor+=i:blinkwait10



"#########################################################################
" shift-tab = previous  tab
map   <S-tab>  :bprev<cr>:echo @%<cr>

" tab = next tab
map   <tab>    :bnext<cr>:echo @%<cr>


"#########################################################################
" function f keys :-
" f2 = (echo) show current file name
map  <f2>     :echo @%<cr>

nmap <F3><f3> :buffers<cr>:b<Space>
nmap <f3> :b #<cr>

" the show-file-subs button
map  <F4>  :TlistToggle<cr>
"let Tlist_File_Fold_Auto_Close = 1
" following line opens with list TlistToggle on
"let Tlist_Auto_Open = 1

map  <f5>  :tabnew .<cr>

map <f6> :q<cr>
"map <leader><f6> :qa<cr>

"map <f7> :!clear;cplist2RELEASE;cp /home/khoskin/runlist/rt182740-newUnFeb13 /home/khoskin/devweb-root-mount/export/home/khoskin/restartPOOL/RUNSTUFF<cr>
map <f7> :!clear;cplist2RELEASE;. /etc/bash_completion.d/git;runlist "`__git_ps1`"<cr>


"" map <f8> and <f8><f8> has videkah specific connitations . so that has moved to the videkah section

map <c-s> :w<cr>
map <f9> :w<cr>

" f11 , also leader-e . e for explorer, as in file explorer.
map <f11>     :NERDTree<cr>


set pastetoggle=<F12>
map <Leader>i :set paste<cr>i


" <Leader>a is used by perlstacktrace "add" point.

" Leader commands
" leader-b show-buffers
"map <Leader>b :buffers<cr>:b<Space>
map <Leader>b :b#<cr>

map <Leader>ca :%s/^/#/g<cr>:%s/^#\+/#/g<cr>

" leader-e : e for file explorer
map <Leader>e :NERDTree<cr>

" a way using <Leader>f to search for the last search string and find the next open buffer with the last search string, and open that buffer.


"nmap <Leader><Leader><left> :echo "L L left !!!"


" leader-h no-syntax-highlighting . also known as 'hugo' button ( hence h )
map <Leader>h :if exists("syntax_on") <Bar> syntax off <Bar> else <Bar> syntax on <Bar> endif <CR>:echo @%<cr>

" leader-k : 'debug looking here' line
map <Leader>k <esc>0i# debug looking here # TODO rm this line<cr><esc>
map <Leader>l /debug looking here<cr>


map <Leader>g :call GitBlame(@%)<cr>
function! GitBlame (filename)
   echo "BLHAAHAHHAHA " 
    exec '!git blame -w '.a:filename
endfunction

" <Leader>m is being used to toggle mouse usage below.

" leader-n : line numbering
map <Leader>n :set invnumber<cr>

" leader-o : re-open-file
map <Leader>o :e.<cr>

" leader-p : shebang perl line . with a use strict ,  warnings n Data::Dumper.
map <Leader>p <esc>1G0i#!/usr/bin/perl<cr>use warnings;<cr>use strict;<cr>use 5.14.2;<cr>use Data::Dumper;<cr><esc>
map <Leader>pp <esc>1G0ipackage  ;<cr>use warnings;<cr>use strict;<cr>use Data::Dumper;<cr><esc>

" leader-q : quit
map <Leader>q :quit<cr>

nmap <Leader>r <esc>A # TODO rm this line<cr><esc>

" leader-s : see below
" leader-t : terminal , well ConqueTerm-Bash terminal.
map <leader>t :ConqueTerm bash<cr>
map tt :ConqueTerm bash<cr>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" splitting windows, and nav between the windows.
" leader-s : split window horizontally
map <Leader>s :split<cr>
" leader-v : split window vertically
map <Leader>v :vsplit<cr>
"" this doesn't work :map <1-LeftMouse>v :vsplit<cr>

"alt-s   strip trailing spaces
"map <S-F12> :%s/\s\+$//

" move with ctrl up or down ( when you have split windows )
nmap <silent> <A-Up> :wincmd k<CR>
nmap <silent> <A-Down> :wincmd j<CR>
nmap <silent> <A-Left> :wincmd h<CR>
nmap <silent> <A-Right> :wincmd l<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle the pesky mouse functionality
nnoremap mm :call ToggleMouse()<CR>
nnoremap <leader>m :call ToggleMouse()<CR>

function! ToggleMouse()
  if &mouse == 'a'
    set mouse=
    echo "Mouse usage disabled"
  else
    set mouse=a
    echo "Mouse usage enabled"
  endif
endfunction

"map <s-f12> :call BrowserRTTicket ()<CR>
"map <f12> :call Browser ()<CR>
"function! Browser ()
"    " attempt to find an http[s] link in the current line
"    let line = getline (".")
"    let httplink = matchstr (line, "http[s]*://[^ ,;\t]*")
"    if httplink ==""
"        let httplink = matchstr (line, "www\.[^ ,;\t]*")
"    endif
"
"    " Venda specific : look for a 4 or more digit number and assume it's an rt ticket number
"    " only if we don't already have a link to open.
"    if httplink == ""
"        let matchnum = matchstr (line, "[0-9][0-9][0-9][0-9][0-9]*")
"        if matchnum != ""
"            let httplink = "http://rt.uk.venda.com/Ticket/Display.html?id=".matchnum
"        endif
"    endif
"
"    " if we've got something to open , open it in firefox
"    if httplink != ""
"        exec ":silent !firefox ".httplink." & "
"        exec ":redraw!"
"        echo "found link : ".httplink
"    else
"        echo "Couldn't http link in current line"
"    endif
"
"endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" whitespace and commenting functions. Not really a core part of videkah navigation
"
vmap <Leader><space> :call VisualSelectionTrimTrailingSpace_n_tabs2spaces()<cr>
function! VisualSelectionTrimTrailingSpace_n_tabs2spaces()
    " on the current visual selection trim all trailing spaces at the end of lines
    " also convert all leading tabs into 4 spaces.

    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]

    let ln = lnum1

    while ln <= lnum2

        let linestr = getline(ln)

        " strip of trailing spaces :-
        let linestr = substitute ( linestr, '\s\+$','','' )

        " TODO the whole changing leading tabs to spaces doesn't yet work .
        " change leading tabs to 4 spaces :-
        "let origlinestr = linestr
        "
        "let linestr = substitute ( linestr, '^\t','    ','' )

        call setline( ln, linestr )
        let ln += 1
    endwhile

endfunction

" adding and removing hashes at the front of a line functions
nmap <leader># <esc>0i#<esc>j0i#<esc>j0i#<esc>j
vmap <leader># <esc>:call Hashline()<cr>
vmap <leader>## <esc>:call RemoveLeadingHashline('one')<cr>
vmap <leader>### <esc>:call RemoveLeadingHashline('multi')<cr>
function! Hashline()

    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]

    let ln = lnum1

    while ln <= lnum2
        call setline(ln,"#".getline(ln))
        let ln += 1
    endwhile

endfunction

function! RemoveLeadingHashline(oneOrMulti)

    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]

    let ln = lnum1

    while ln <= lnum2

        if ( a:oneOrMulti ) == 'multi'
            call setline( ln , substitute(getline(ln),'^\#\+',"","") )
        else
            call setline( ln , substitute(getline(ln),'^\#',"","") )
        endif

        let ln += 1
    endwhile

endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Beginning of videkah stuff .
""""""""""""""""""""""""""""""

"source $HOME/.vim/videkah/bin/vimrc_libpaths
let g:videkah_config_buffer_name = '.videkah/config'
let g:videkah_config_value = []

" the dir at videkah startup.
let g:videkah_start_dir = getcwd()

set autowrite       "Save buffer automatically when changing files

augroup videkah
    autocmd!
    autocmd BufLeave .videkah/config call Populate_videkah_config()
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <f8> :qa<cr>
"map <f8><f8> :e ~/.vilistrun<cr>:w<cr>:qa<cr>
map <f8><f8> :call QuitAndReloadVidekah()<cr>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vmap <return> :call OpenSomethingFromVisualSelection_n_Enter()<cr>
" with the double return , just do the ack-grep search.
vmap <return><return> :call SearchForVisualSelection_with_ackgrep()<cr>
" 1 should be the filelist

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" videkah <space>-something mappings.
"<space>sumin key mappings
nnoremap <Space> :call SelectNext_videkah_special_buffer()<cr>

"select videkah_filelist
nnoremap <Space>f :call Select_g_videkah_buffer('videkah_filelist')<cr>
nnoremap <Space>a :call AddCurrentBufferNameToFileList()<cr>
nnoremap <Space><space> :call Select_g_videkah_buffer('videkah_filelist')<cr>

nnoremap <Space>t :call Select_g_videkah_buffer('videkah_perl_stacktrace')<cr>

"select videkah_perl_static_class_hierarchy
nnoremap <Space>h :call Select_g_videkah_buffer('videkah_perl_static_class_hierarchy')<cr>

"select videkah_ackgrep
nnoremap <Space>g :call Select_g_videkah_buffer('videkah_perl_ackgrep')<cr>

"select videkah_runlist :-
nnoremap <Space>r :call Select_g_videkah_buffer('videkah_runlist')<cr>

"select videkah_runlist :-
nnoremap <Space>c :call Select_g_videkah_buffer('videkah_config')<cr>

function! SelectNext_videkah_special_buffer()
    if ! IsVidekahMode()
        echo ''
        return ''
    endif

    " Loops over selecting the next special videkah buffer. operated with a single <space>
    if ! exists("g:videkah_selected_buffer")
        let g:videkah_selected_buffer = "videkah_config"
    endif

    " list of symbolic buffernames (well some of them are symbolic, others are the REAL thing, but these will change too ) :-
    let videkah_list_of_buffers = [ "videkah_filelist", "videkah_runlist", "videkah_perl_stacktrace", "videkah_perl_static_class_hierarchy", "videkah_perl_ackgrep",  "videkah_config" ]

    " find where our currently selected buffer is in the list of special videkah buffers.
    let lcount = 0
    let found = ''
    for i in videkah_list_of_buffers
        if i == g:videkah_selected_buffer
            let found = lcount
        endif
        let lcount += 1
    endfor

    " we want to select the next special videkah buffer so :-
    let found += 1

    " if we've rolled of the end of buffers, rotate back around to the first one.
    if found >= len(videkah_list_of_buffers)
        let found = 0
    endif

    " now we have the buffer that is going to be the next videkah special buffer selected.
    let g:videkah_selected_buffer = videkah_list_of_buffers[found]

    call Select_g_videkah_buffer(g:videkah_selected_buffer)

endfunction

function! Select_g_videkah_buffer(change_to)
    " select one of the buffers with a special meaning to videkah.
    " the videkah_filelist , videkah_runlist , videkah_config etc are symbolic names and not the ACTUAL name of the buffer.
    " ALL attempts at opening at special videkah buffer should come through this function,
    " since it does the translation from symbolic-name to actual name on the filing system.
    if ! IsVidekahMode()
        echo ''
        return ''
    endif

    if ( empty (g:videkah_config_value) || Trim(@%) == Trim(g:videkah_config_buffer_name) )
        " so populate the videkah_config_value array either if it is empty
        " or if the current buffer is videkah_config because it is probably
        " going to change to something different, and this will populate any changes
        call Populate_videkah_config()
    endif

    if ! a:change_to
        let g:videkah_selected_buffer = a:change_to
    endif

    " "videkah_config" is a symbolic buffer name.
    if g:videkah_selected_buffer == "videkah_config"
        call TryAndOpenFileName(g:videkah_config_buffer_name)
        echo "selected ".g:videkah_selected_buffer
        return
    endif

    let real_filename = Get_videkah_buffer_real_filename(g:videkah_selected_buffer)

    if real_filename == ''
        return ''
    endif

    call TryAndOpenFileName(real_filename)
    echo "selected ".g:videkah_selected_buffer

endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" videkah SelectLineOn_ xxxxxx section.

nmap <return>     :call SelectLineOn_dispatcher("keyb")<cr>
map <2-LeftMouse> :call SelectLineOn_dispatcher("mouse")<cr>

function! SelectLineOn_dispatcher(mouseORkeyb)
    if ! IsVidekahMode()
        echo ''
        return ''
    endif

    " The main SelectLineOn dispatch function.
    " a single <return> is pressed on different buffers,
    " and this will do different selections
    " ( SelectLineOn_ actions )
    "
    if empty (g:videkah_config_value)
        call Populate_videkah_config()
    endif

    " this function is called with a single <return> or <2-LeftMouse> click. In NON-visual mode.
    " @% is the current filename
    if IsCurrentVidekahBuffer("videkah_filelist")
        " we are in the filelist so we'll try and open the current line.
        let filename = Trim(getline("."))
        echo ''
        if filereadable(filename)
            return TryAndOpenFileName (filename)
        else
            call GotoPerlModuleIfFileExists(filename,'')
            return
        endif
    endif

    if IsCurrentVidekahBuffer("videkah_runlist")
        return SelectLineOn_videkah_runlist()
    endif

    if IsCurrentVidekahBuffer("videkah_perl_stacktrace")
        return SelectLineOn_videkah_perl_stacktrace()
    endif

    if IsCurrentVidekahBuffer("videkah_perl_static_class_hierarchy")
        return SelectLineOn_videkah_perl_static_class_hierarchy()
    endif

    if IsCurrentVidekahBuffer("videkah_perl_ackgrep")
        return SelectLineOn_videkah_perl_ackgrep()
    endif

    " the videkah_config can't use IsCurrentVidekahBuffer because that relies
    " on the videkah buffer being specified by stuff in the videh_config so we have to :-
    if ( Trim(@%) == Trim(g:videkah_config_buffer_name) )
        echo ''
        return ''
    endif

    " so we aren't in a filelist, perlstacktrace or perl_static_class_hierarchy buffer
    if ( SelectLineNo_GotoPerlUseModule() )
        echo ''
        return ''
    endif
    echo "not navigating anywhere"

endfunction

function! SelectLineOn_videkah_runlist()
    if ! IsVidekahMode()
        return ''
    endif

    if ! IsCurrentVidekahBuffer("videkah_runlist")
        echo "SelectLineOn_videkah_runlist() called, and we're not on the correct buffer"
        return
    endif

    " so if we are doing the select (<return> or double-mouse click) on a runlist line do the special stack trace stuff.
    let run_from_basedir = Get_videkah_config('RUN_FROM_BASEDIR')

    "echo "g start dir ".g:videkah_start_dir."      getcwd=".getcwd()

    if ( ! g:videkah_start_dir )
        let g:videkah_start_dir = getcwd()
    endif

    lcd g:videkah_start_dir

    if ( run_from_basedir )
        let $VIDEKAH_PATH = run_from_basedir
    else
        let $VIDEKAH_PATH = g:videkah_start_dir
    endif
    lcd $VIDEKAH_PATH

    exec ':!'.getline('.')

    let g:testcwd = getcwd()

    " change back to basedir
    let $VIDEKAH_PATH = g:videkah_start_dir
    silent lcd $VIDEKAH_PATH

endfunction

function! SelectLineOn_videkah_perl_stacktrace()
    if ! IsVidekahMode()
        return ''
    endif

    " only what to run this SelectLine on a line in the perlstacktrace buffer
    if ! IsCurrentVidekahBuffer("videkah_perl_stacktrace")
        echo "SelectLineOn_videkah_perl_stacktrace() called, and we're not on the correct buffer"
        return
    endif

    " so if we are doing the select (<return> or double-mouse click)  on a perlstacktrace line
    let thisline = getline('.')

    if ( ! empty(matchstr(thisline,"^INSERTED")) || !empty(matchstr(thisline,"^PROCESSED")))

        let thisline = substitute( thisline,"^INSERTED ","","")
        let thisline = substitute( thisline,"^PROCESSED ","","")
        " gets the number to the right of the INSERTED or PROCESSED :-
        let number = matchstr(thisline, "^[0-9]*")
        if ! empty( number )
            " need to change GOTO_PERLSTACKTRACE_LOC number.
            if (  search("^GOTO_PERLSTACKTRACE_LOC" ,"") )
                call setline('.',"GOTO_PERLSTACKTRACE_LOC ".number)
                call PerlStacktrace_main("current")
            else
                echo "ERROR couldn't set GOTO_PERLSTACKTRACE_LOC"
            endif
        endif
    else
        echo "( perl_stacktrace buffer ) Select Line : not on an INSERTED or PROCESSED line. can't go anywhere"
    endif
endfunction

function! SelectLineOn_videkah_perl_static_class_hierarchy()
    if ! IsVidekahMode()
        return ''
    endif

    " so we are doing the select (<return> or double-mouse click) on a perl_static_class_hierarchy line .

    " only what to run this SelectLineOn in the perl_static_class_hierarchy
    if ! IsCurrentVidekahBuffer("videkah_perl_static_class_hierarchy")
        echo "SelectLineOn_videkah_perl_static_class_hierarchy() called, and we're not on the correct buffer."
        return
    endif

    if ( ! empty (matchstr(getline("."),"^TREE ")))

        let fileORmodule = substitute(getline('.'),'^TREE\s\+','','')
        return GotoPerlModuleIfFileExists (fileORmodule,"")
    endif

    if ( ! empty (matchstr(getline("."),"^PROCESSED ")))
        "PROCESSED 0 FILE=venda-modules/Venda/Payment/Mode.pm LINE=36 PACKAGE=Venda::Payment::Mode SUB=status

        let fileORmodule = matchstr(getline('.'),'FILE=.*')
        let fileORmodule = substitute(fileORmodule,'\s\+.*','','')
        let fileORmodule = substitute(fileORmodule,'^FILE=','','')
        let thesub = matchstr(getline('.'),'SUB=.*')
        let thesub = substitute(thesub,'^SUB=','','')
        "echo "fileORmodule=".fileORmodule."  :  thesub=".thesub
        return GotoPerlModuleIfFileExists (fileORmodule,thesub)
    endif

    echo "( perl_static_class_hierarchy buffer ) Select line : not on a TREE or PROCESSED line. can't go anywhere"

endfunction
function! SelectLineOn_videkah_perl_ackgrep()
    if ! IsVidekahMode()
        return ''
    endif

    " so we are doing the select (<return> or double-mouse click) on a videkah_perl_ackgrep line
    " only what to run this SelectLine in the perl_static_class_hierarchy
    if ! IsCurrentVidekahBuffer("videkah_perl_ackgrep")
        echo "SelectLineOn_videkah_perl_ackgrep() called, and we're not on the correct buffer"
        return
    endif

    " extract the filename from the front of the current line with non-greedy match upto the first colon
    let filename = matchstr(getline("."), '^.\{-}:')
    if ! empty ( filename )
        let filename  = substitute(filename , ':$', '','' )

        let lineno = matchstr(getline(".") , ':\d\+:')

        if ! empty (lineno)

            let lineno = substitute( lineno , ':$', '','' )
            let lineno = substitute( lineno , '^:', '','' )
            call TryAndOpenFileName( filename )
            exec lineno
        endif
        return
    endif

    echo "( perl_ackgrep buffer ) Select line : don't seem to be able to navigate to the ackgrep line"

endfunction

function! SelectLineNo_GotoPerlUseModule()
    if ! IsVidekahMode()
        return ''
    endif

    " goto what might be a perl module definition on the current line, or maybe do a perl_static_class_hierarcy

    " this gets run by the main SelectLineNo_ dispatcher
    " when <return> or double-mouse-clist is pressed on a line in a
    " buffer that isn't one of the following types :-
    "   perlstacktrace
    "   filelist
    "   runlist
    "   perl_static_class_hierarchy
    "   perl_ackgrep
    "
    " if the perl line starts with "use", "require", "with" or "extends" and has a module name attempt to open that file in
    " on of the defined "lib" dirs

    let currline = getline(".")

    let currline = substitute(currline,'^[# ]\+',"","") "remove leading spaces and hashes

    " now if it is a 'use base', 'with' or 'extends'  line, go and do a perl_static_class_hierarchy on the file.
    for try_regex in [ '^with', '^extends', '^use\s\+base', '@ISA' ]
        let founduseb_ext_with = matchstr( currline, try_regex )
        if ! empty ( founduseb_ext_with )
            call FindSubIn_perl_static_class_hierarchy(@%, '')
            return 1
        endif
    endfor

    " if it just begins with 'use' or 'require' go to the module specified.
    for try_use_or_require in [ 'use', 'require' ]
        let founduse = matchstr( currline, '^'.try_use_or_require )
        if ! empty (founduse)
            " strip of the front "use or require or with "
            let themodule = substitute(currline, '^'.try_use_or_require.'\s\+','','')

            " strip of the trailing stuff after the first space.
            "let themodule = substitute(themodule ,"\\s\\+qw.\\+","","")
            let themodule = substitute(themodule ,'\s\+.\+','','')
            let themodule = substitute(themodule,';$','','')
            let themodule = substitute(themodule,',$','','') " from a with statement

            let themodule = substitute(themodule,"^'",'','') " from a with statement
            let themodule = substitute(themodule,'^"','','') " from a with statement
            let themodule = substitute(themodule,"'$",'','') " from a with statement
            let themodule = substitute(themodule,'"$','','') " from a with statement

            let themodule = substitute(themodule,'\s\+$','','')

            return GotoPerlModuleIfFileExists (themodule,'')
        endif
    endfor

    return 0
endfunction

function! OpenSomethingFromVisualSelection_n_Enter ()
    if ! IsVidekahMode()
        echo ''
        return ''
    endif

    " need to be able to try say My::Module::Mysubname , see if the file exists. if it doesn't exist then try to see if My::Module file exists , if it does search for "sub Mysubname"

    " need to be able to split up My::Module->myclassmethod up, see if My::Module file exists if it does open it and search for "sub myclassmethod"

    " if a visual selection is just "->methodname" go grepping in all the libpaths for the "sub methodname" 

    " if all of the above fail grep for whatever is in the visual selection , show in a "search" buffer . in the search buffer pressing return on one of the lines will take you to the place.


    " if it has a trailing ->blah get rid of that immediately

"    let subname = matchstr(visel, "->

" if it is a $self->methodName search only the current file for "sub methodname" . of course this could be extended by Looking for 'extend' lines in Moose classes, and use base lines, but these will be for a later step.
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    "strip of ( and anything after it.
    let visel = Lhvisualselection()
    let visel = substitute(visel,'(.*','','')
    let visel = substitute(visel,'\s\+','','g') " remove all space
    let visel = substitute(visel,';$','','') " remove trailing semi-colons

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " is it a $self->methodname or $class->methodname ?
    " if so search in local buffer.
    " if that fails look for a "use base" or "extends"

    if ( ! empty ( matchstr(visel,'^$*\(self\|class\|klass\)->')) ) " TODO make the $ optional in a better way than just the * wildcard.
        " so our visual search is looking for method names of this or its parent classes/roles
        " lets try and do a very static search in the current file, and any of its parent/role classes and see how many subs might be called by it.
        let subname = matchstr(visel,'->.*')
        let subname = substitute(subname, '->',"","")
        call FindSubIn_perl_static_class_hierarchy(@%, subname)
    endif

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " try the module->method notation
    if ! empty ( matchstr(visel, '.\+->' ) )
        let modulename = substitute(visel,'->.*',"","")
        let subname = matchstr(visel,'->.*')
        let subname = substitute(subname, '->',"","")

        " if we got here we're not going to try anything else ,
        " so return.
        return GotoPerlModuleIfFileExists(modulename,subname)
    endif
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " try "^->methodname" and ack-grep all the ackgrep-libpaths for "sub methodname"

    if ! empty ( matchstr(visel, '^->'))
        " so the match is the ->sumin , this assume you want to look the method name up in the super class
        let methodname = substitute(visel,'^->', '', '')

        " please note the following regex looking thing in
        " call FindSubIn_videkah_perl_ackgrep is getting fed to ack-grep
        " and is different from vimscript regexs. i.e. the + isn't \+ (So DON'T change it)
        call FindSubIn_videkah_perl_ackgrep('sub\s+'.methodname)
        return 1
    endif

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " try the my::module::name::methodname
    let modulename = visel
    let subname    = ''
    if ( GotoPerlModuleIfFileExists(modulename,subname) == 0 )
        " get the module name up to the last :: or '
        let modulename = matchstr(visel,".*\\(::\\|'\\)")

        " get the subname by removing the modulename from visel
        let subname    = substitute(visel,modulename,"","")
        " now modulename can have its last :: or ' removed
        let modulename = substitute(modulename,'\(::\|'."'".'\)$',"","")

        let diditwork = GotoPerlModuleIfFileExists(modulename,subname)
    endif

endfunction

function! FindSubIn_perl_static_class_hierarchy(startperlmodule,  subname)
    if ! IsVidekahMode()
        return ''
    endif

    " used for visual selections on $self->methodname
    " and for when <return> or double-mouse-click is done on an use base, extends or with line.

    call Select_g_videkah_buffer('videkah_perl_static_class_hierarchy')

    " empty the buffer :-
    exec ":1,".line("w$")."delete _"

    call append(0, "LIBPATHS=".join( GetPerlLibPaths() ))
    call append(0, "SUBNAME=".a:subname )
    call append(0, "STARTPERLMODULEFILE=".a:startperlmodule )

    " pipe out the current buffer to the perl filter script
    exec ":silent %!".$HOME."/.vim/videkah/bin/videkah_perlfindsubinclasses.pl"
    exec ":silent w!"

endfunction

function! SearchForVisualSelection_with_ackgrep()
    if ! IsVidekahMode()
        echo ''
        return ''
    endif

    let visel = Lhvisualselection()
    call FindSubIn_videkah_perl_ackgrep(visel)

endfunction

function! FindSubIn_videkah_perl_ackgrep(searchstring)
    if ! IsVidekahMode()
        return ''
    endif

    " this filters the videkah_perl_ackgrep buffer and turns it
    " into the navigatable buffer by calling the ack-grep script.
    " used for visual selections on $self->methodname.

    call Select_g_videkah_buffer('videkah_perl_ackgrep')

    " empty the buffer :-
    exec ":1,".line("w$")."delete _"

    let ackgrep_libpaths = Get_videkah_config('ACKGREP_PATHS')
    let t_libpaths = ''
    if ! empty(ackgrep_libpaths)
        let t_libpaths = Trim(ackgrep_libpaths[0])
    endif
    if ! t_libpaths
        " if the ACKGREP_PATHS were useless lets default back to the PERL_LIBPATHS
        let t_libpaths = Trim(join( GetPerlLibPaths() ))
    endif

    call append(0, "LIBPATHS=".t_libpaths)
    call append(0, "SEARCHSTRING=".a:searchstring )

    " pipe out the current buffer to the perl filter script
    exec ":silent %!".$HOME."/.vim/videkah/bin/videkah_perl_ackgrep.pl"
    exec ":silent w!"

endfunction

function! Lhvisualselection()
  try
    let a_save = @a
    normal! gv"ay
    return @a
  finally
    let @a = a_save
  endtry
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" videkah Perl Stack Trace navigation 2014-01-29 karl khaos hoskin
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" all the key mappings and a quick description of what they do first :-
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" go backward in the stack trace
nmap <Leader><left> :call PerlStacktrace_main("backward")<cr>
"""""""""""""""""""""""""""""""""""""""""""""""
" go forward in the stack trace
nmap <Leader><right> :call PerlStacktrace_main("forward")<cr>
"""""""""""""""""""""""""""""""""""""""""""""""
" to the current position in the stack trace ( don't move perlstacktrace_loc pointer )
nmap <Leader><down> :call PerlStacktrace_main("current")<cr>
"""""""""""""""""""""""""""""""""""""""""""""""
" up just open up the perlstacktrace buffer
nmap <Leader><up> :call Select_g_videkah_buffer('videkah_perl_stacktrace')<cr>
"""""""""""""""""""""""""""""""""""""""""""""""
" add the current file and line to one of the points on the trace navigation
" tries to add at the point of after the current perlstacktrace_loc
" if it can't it just adds it somewhere.
nmap <Leader>a :call PerlStacktrace_addline()<cr>
"""""""""""""""""""""""""""""""""""""""""""""""

function! PerlStacktrace_addline()
    if ! IsVidekahMode()
        return ''
    endif

    let filename=@%
    let linenum=line('.')

    call Select_g_videkah_buffer('videkah_perl_stacktrace')

    if (  search("^GOTO_PERLSTACKTRACE_LOC" ,"") )
        let g:perlstacktrace_loc = substitute( getline("."),"^GOTO_PERLSTACKTRACE_LOC\\s*","","") * 1
    else
        "adding a line when there are any processed or inserted lines to flick between
        exec append(0,"INSERTED 0 FILE=".filename." LINE=".linenum." PACKAGE= SUB=")
        call PerlStacktrace_main("current")
        return
    endif

    if ( search("PROCESSED ".g:perlstacktrace_loc , "" ))
        exec append(line('.'),"INSERTED 0 FILE=".filename." LINE=".linenum." PACKAGE= SUB=")
        call PerlStacktrace_main("backward")
    else
        if ( search("INSERTED ".g:perlstacktrace_loc , "" ))
            exec append(line('.'),"INSERTED 0 FILE=".filename." LINE=".linenum." PACKAGE= SUB=")
            call PerlStacktrace_main("backward")
        endif
    endif

endfunction

function! PerlStacktrace_main ( direction )
    if ! IsVidekahMode()
        return ''
    endif

    call Select_g_videkah_buffer('videkah_perl_stacktrace')

    " see if the perlstacktrace buffer has the line
    " GOTO_PERLSTACKTRACE_LOC
    " if it does use that for the g:perlstacktrace_loc
    if (  search("^GOTO_PERLSTACKTRACE_LOC" ,"") )
        let g:perlstacktrace_loc = substitute( getline("."),"^GOTO_PERLSTACKTRACE_LOC\\s*","","") * 1
    endif

    if ! exists("g:perlstacktrace_loc")
        let g:perlstacktrace_loc = 0
    else
        if a:direction == "forward"
            let g:perlstacktrace_loc = g:perlstacktrace_loc - 1
        endif
        if a:direction == "backward"
            let g:perlstacktrace_loc = g:perlstacktrace_loc + 1
        endif
        " we don't have to do anything for "current" , the pointer stays the same
    endif

    " so I'm passing the current perlstacktrace_loc into the perlstacktrace.pl filter
    " in a different way to what is obvious ( you'd have thought I'd use the GOTO_PERLSTACKTRACE_LOC)
    " this is sort of a vestigial way, coz its what I came up with first, before
    " I'd ever dreamed of GOTO_PERLSTACKTRACE_LOC. TODO (for karl) change this .
    call append(0, "LIBPATHS=".join( GetPerlLibPaths() ))
    exec append(0,"perlstacktrace_loc=".g:perlstacktrace_loc)

    " :%!cmd  (replace the buffer ) . :w !cmd (write buffer to external command)
    exec ":silent %!".$HOME."/.vim/videkah/bin/videkah_perlstacktrace.pl"
    exec ":silent w!"

    " we should have some GOTO_FILE , GOTO_LINE , GOTO_SUB in the perlstacktrace buffer now.
    let goto_file=""
    let goto_line=0
    let goto_sub =""

    " TODO need to check if the file exists before we try and go to it.

    if ( search("^GOTO_FILE" ,"") )
        let goto_file = substitute( getline("."),"^GOTO_FILE\\s*","","")
        "echo "goto file ".goto_file
        if ( search("^GOTO_LINE" ,"") )
            let goto_line = substitute( getline("."),"^GOTO_LINE\\s*","","")
        endif
        if ( goto_line > 0 )
            "do it
            exec ":silent e ".goto_file
            exec goto_line
        else
            if ( search("^GOTO_SUB" ,"") )
                let goto_sub = substitute( getline("."),"^GOTO_SUB\\s*","","")
                "do it
                exec ":silent e ".goto_file
                if ! search( "^sub\\s*".goto_sub , "")
                    echo "NOT found goto sub ".goto_sub
                endif
            endif
        endif
    endif

endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! QuitAndReloadVidekah()
    " write out the file that will reopen vim again.
    " the videkah shell script looks for this file, and will reopen vim in videkah mode
    " only when this file is present.
    "
    " <f8><f8> usually triggers this.
    "
    if ! IsVidekahMode()
        echo ''
        return ''
    endif
    exec ":w!"
    exec ":e .videkah/keep_videkah_open"
    exec ":w!"
    exec ":qa"

endfunction

function! IsVidekahMode()
    if ( bufnr(g:videkah_config_buffer_name) != -1 )
        " so we have a buffer called '.videkah/config' assume we're in videkah mode.
        return 1
    endif
    return 0
endfunction

function! GetGitBranchName()
    " so this will NOT cope with a git branch called 'fatal', I guess that could be a bug. TODO maybe fix this.

    let gitbranch = Trim( system ( "git symbolic-ref HEAD | sed 's!refs\/heads\/!!'" ) )
    

    " TODO fix this . this breaks if it isn't a git repo
    return gitbranch
endfunction


"function! IsCurrentVidekahBuffer(VidekahBufferSymbolicName)
"HERE
    """""" WHAT ITS GONNA BE :- let videkah_list_of_buffers = [ "videkah_filelist", "videkah_runlist", "videkah_perl_stacktrace", "videkah_perl_static_class_hierarchy", "videkah_perl_ackgrep",  "videkah_config" ]
    "let videkah_list_of_buffers = [ "videkah_filelist", "videkah_runlist", "perlstacktrace", "perl_static_class_hierarchy", "videkah_perl_ackgrep",  "videkah_config" ]

"endfunction

function! IsCurrentVidekahBuffer(videkah_symbolic)
    " detects if the current buffer is the defined type of videkah buffer
    if ( Trim(@%) == Trim(Get_videkah_buffer_real_filename(a:videkah_symbolic)) )
        return 1
    endif
    return 0
endfunction

function! Get_videkah_buffer_real_filename(videkah_symbolic)
    " gets the proper filename for a videkah buffer.
    " thus translating from the symbolic name, and getting the real thing.
    " This requires looking at the videkah config, finding out the directory, and seeing if its
    " name is related to the git-branch.
    if ! IsVidekahMode()
        " we can only find this info out if we are in videkah mode, with its config.
        return ''
    endif

    let videkah_symbolic = toupper(a:videkah_symbolic)

" TODO some sort of check to say if its a valid videkah_symbolic buffername
"    if (videkah_symbolic != 'FILE' && videkah_symbolic !='RUN' )
"        echo "Get_Run_Or_FileList_filename called with '".videkah_symbolic."'. this is not RUN or FILE and is not valid"
"        " TODO raise an exception
"        return
"    endif


    let list_by_git_branch = Get_videkah_config(videkah_symbolic.'_BY_GIT_BRANCH')
    if empty (list_by_git_branch)
        echo "can't get parameter ".videkah_symbolic.'_BY_GIT_BRANCH'
        " TODO raise an exception
        return
    endif

    let list_dir = Get_videkah_config(videkah_symbolic.'_DIR')
    if empty (list_dir)
        echo "can't get parameter ".videkah_symbolic.'_DIR'
        " TODO raise an exception
        return
    endif

    " strip off leading videkah from the videkah_symbolic
    let short_symbolic = substitute(tolower(videkah_symbolic),'videkah_','','')

    if ( list_dir[0] == '' )
        " so we are going to be in one of the local .videkah/XXXXXX dirs to store files.
        let list_dir[0] = '.videkah/'.short_symbolic
    endif

    " need a trailing / on the dir name.
    if empty ( matchstr( list_dir[0] , '/$', ''))
        let list_dir[0] .= "/"
    endif

    if list_by_git_branch[0]
        " so we need the gitbranch name
        let filename = list_dir[0].GetGitBranchName()
    else
        let filename = list_dir[0].tolower(short_symbolic)
    endif

    return filename

endfunction


function! GetPerlLibPaths()
    if ! IsVidekahMode()
        " we can only find this info out if we are in videkah mode, with its config.
        " the calling routine is expecting an array , so returning a string will blow up.
        return ''
    endif

    let perl_libpaths = Get_videkah_config('PERL_LIBPATHS')

    if ( ! empty( perl_libpaths ) )
        let arr = split(perl_libpaths[0] ,'\s\+')
        return arr
    else
        echo "can't find PERL_LIBPATHS in the buffer ".g:videkah_config_buffer_name
        return []
    endif

endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" get the videkah config stuff.
" with the config options that haven't yet been implemented :-
"let g:videkah_config_fieldnames = [ 'VIDEKAH_FILELIST_DIR', 'VIDEKAH_FILELIST_BY_GIT_BRANCH', 'VIDEKAH_RUNLIST_DIR', 'VIDEKAH_RUNLIST_BY_GIT_BRANCH', 'VIDEKAH_PERL_ACKGREP_DIR', 'VIDEKAH_PERL_ACKGREP_BY_GIT_BRANCH', 'VIDEKAH_PERL_STACKTRACE_DIR', 'VIDEKAH_PERL_STACKTRACE_BY_GIT_BRANCH', 'VIDEKAH_PERL_STATIC_CLASS_HIERARCHY_DIR', 'VIDEKAH_PERL_STATIC_CLASS_HIERARCHY_BY_GIT_BRANCH', 'RUN_FROM_BASEDIR', 'PERL_LIBPATHS', 'ACKGREP_PATHS', 'MAX_VIDEKAH_PERL_STACKTRACE_BUFFERS', 'MAX_VIDEKAH_PERL_ACKGREP_BUFFERS', 'MAX_VIDEKAH_PERL_STATIC_CLASS_HIERARCHY_BUFFERS', 'OPEN_ALL_FILELIST_AT_STARTUP' ]

let g:videkah_config_fieldnames = [ 'VIDEKAH_FILELIST_DIR', 'VIDEKAH_FILELIST_BY_GIT_BRANCH', 'VIDEKAH_RUNLIST_DIR', 'VIDEKAH_RUNLIST_BY_GIT_BRANCH', 'VIDEKAH_PERL_ACKGREP_DIR', 'VIDEKAH_PERL_ACKGREP_BY_GIT_BRANCH', 'VIDEKAH_PERL_STACKTRACE_DIR', 'VIDEKAH_PERL_STACKTRACE_BY_GIT_BRANCH', 'VIDEKAH_PERL_STATIC_CLASS_HIERARCHY_DIR', 'VIDEKAH_PERL_STATIC_CLASS_HIERARCHY_BY_GIT_BRANCH', 'RUN_FROM_BASEDIR', 'PERL_LIBPATHS', 'ACKGREP_PATHS' ]

function! Populate_videkah_config()

"    echom "running Populate_videkah_config"

    " need to get keep the currbuffer, so we can revert to it latter
    let currbuffer = @%
    if ! TryAndOpenFileName(g:videkah_config_buffer_name)
        " we didn't manage to open the videkah config, so we can't load its values.
        echo "can't open the ".g:videkah_config_buffer_name
        return ''
    endif

    " all this terrible code is because I can't seem to get associative arrays to work for me.
    " so I've got to do them MANUALLY.

    " because we have to use "add" to the end of the array , we need to
    " reset the array here :-
    let g:videkah_config_value = []

    let tcount = 0
    for i in g:videkah_config_fieldnames
        call add( g:videkah_config_value , GetParameterFromCurrentBuffer(i) )
    "    echo tcount." ".i."  ".g:videkah_config_value[tcount][0]
        let tcount += 1
    endfor
    return

    "for i in g:videkah_config_fieldnames
    "    echo "TEST ".i.' == '.Get_videkah_config(i)[0]
    "endfor

    call TryAndOpenFileName(currbuffer)

endfunction

function! Get_videkah_config(FIELDNAME)
    " gets the value of the specified FIELDNAME from the config.
    let tcount = 0
    for i in g:videkah_config_fieldnames
        if ( i == a:FIELDNAME )
            return g:videkah_config_value[tcount]
        endif
        let tcount += 1
    endfor
    echo "Get_videkah_cofnig couldn't find the field ".a:FIELDNAME
    return

endfunction

function GetParameterFromCurrentBuffer ( parameter )
    " returns an ARRAY . so you can tell if it is "empty" , i.e. no value found, which is different from having a boolean-false/0/empty-string response ( which might be valid )
    " in fact the parameter should really only be A-Z , underscore, and 0-9,
    if ( empty ( matchstr( a:parameter, '^[A-Za-z0-9_]\+$')))
        echo "GetParameterFromCurrentBuffer() the parameter ".a:parameter." has illegal characters"
        return []
    endif
    if ( search('^\s*'.a:parameter.'\s*=' ) ) " the search really needs to be case-insensitive <- TODO
        let theparam = Trim(substitute( getline("."),'^\s*'.a:parameter.'\s*=','',''))

        "echo "GetParameterFromCurrentBuffer ".a:parameter." === ".theparam
        return [ theparam ]
    endif
    echo "GetParameterFromCurrentBuffer can't find ".a:parameter." in ".@%
    return []
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! AddCurrentBufferNameToFileList()

    let filename2add = Trim(@%)

    call Select_g_videkah_buffer('videkah_filelist')

    " search the filelist and see if it already exists.
    " if it does exist, don't bother re-adding it. just select that line in the filelist.
    if ( search('^\s*'.filename2add.'\s*$' ) )
        echo "you've already got ".filename2add." in the filelist"
    else
        call append(0, filename2add)
        exec 0
    endif

endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" general functions, used by many sections of videkah

function! TryAndOpenFileName (buffile)
    " this tries to see if we have a buffer open for the file, if so it
    " will open that, because opening the buffer with :b will preserve the current line number
    " if we don't have it open already , then just do a :e file open.

    " if the current buffer that we're leaving is the videkah_config
    " then we really want to reload the videkah_config
    let buffile=a:buffile
    if ( bufnr(buffile) != -1 )
        " need to do this if we are to stay at the current line , and not reopen the file everytime.
        exec ":silent w!"
        exec ":silent b ". bufnr(buffile)
    else
        " file wasn't in any buffer , so open it up .
        exec ":silent w!"
        exec ":silent e ".buffile
    endif

    " see if we changed buffer.
    if ( @% == buffile )
        return 1
    endif
    return 0

endfunction

function! GotoPerlModuleIfFileExists(themodule,thesubname)
    " given a this::module::name this will search through the likely places in venda app checkout
    " and see if the file is readable. If it is it will switch to that file.
    " echo "called with ".a:themodule."   ".a:thesubname
    "
    " you can also call this with a filename of a .pm and it will work assuming there aren't :: or ' in the filename.

    let themodule = a:themodule
    let themodule = substitute(themodule,"::","/","g") " replace the :: with /
    let themodule = substitute(themodule,"'","/","g")  " replace the perl-classic  ' with /

    let haspm = matchstr(themodule, "\\.pm$")
    if empty(haspm)
        let themodule .= ".pm" "append the .pm
    endif

    for libpath in GetPerlLibPaths()
        let fullpathmodule = libpath.themodule
        if filereadable(fullpathmodule)
            call TryAndOpenFileName(fullpathmodule)
            if ! empty(a:thesubname)
                call search( "^sub\\s*".a:thesubname, "")
            endif
            return 1 " to indicate we did try and open something
        endif
    endfor
    return 0
endfunction

function! Trim(str)
    let txt= a:str

    " these regexes should do what I want,
    " i.e. get rid of all newlines and spaces and tabs
    " before and after the main string

    let txt = substitute(txt,'^\_s\+','','')
    let txt = substitute(txt,'\_s\+$','','')
    return txt
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Wishlist of features and improvements to the code..
""""""""""""""""""""""""""""""

" TODO xmllint --format  output  short cut. on a visual-selection Or an entire file.

" TODO a way of storing all the previously open buffers, and navigating back and forward through them in the sequence they were opened. A stack like thing, working like the browser-back and browser-forward buttons of firefox.

" TODO get all the "exec ':w!' and make them call a common routine that can see if the buffer they are navigating away from is the .videkah/config, and thus fix the re-reading of .videkah/config bug.



" TODO have multiple perlstacktrace / perl_static_class_hierarchy / perl_ackgrep buffers, upto the MAX in the config..

" TODO get the OPEN_ALL_FILELIST_AT_STARTUP config option running.

" TODO implement the PERL_STACK_TRACE_STRIP_REGEX=

" TODO fix the GetGitBranchName when not in a git-repo to return something like NOTGIT

" TODO make the F2 button not only give the current filename , but also in videkah mode give the videkah symbolic name in brackets after the name.


" So <space> cycles through the videkah buffers


